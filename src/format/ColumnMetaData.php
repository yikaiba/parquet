<?php
namespace hongkai\parquet\format;

/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

/**
 * Description for column metadata
 */
class ColumnMetaData
{
    static public $isValidate = false;

    static public $_TSPEC = array(
        1 => array(
            'var' => 'type',
            'isRequired' => true,
            'type' => TType::I32,
        ),
        2 => array(
            'var' => 'encodings',
            'isRequired' => true,
            'type' => TType::LST,
            'etype' => TType::I32,
            'elem' => array(
                'type' => TType::I32,
                ),
        ),
        3 => array(
            'var' => 'path_in_schema',
            'isRequired' => true,
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
                'type' => TType::STRING,
                ),
        ),
        4 => array(
            'var' => 'codec',
            'isRequired' => true,
            'type' => TType::I32,
        ),
        5 => array(
            'var' => 'num_values',
            'isRequired' => true,
            'type' => TType::I64,
        ),
        6 => array(
            'var' => 'total_uncompressed_size',
            'isRequired' => true,
            'type' => TType::I64,
        ),
        7 => array(
            'var' => 'total_compressed_size',
            'isRequired' => true,
            'type' => TType::I64,
        ),
        8 => array(
            'var' => 'key_value_metadata',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\hongkai\parquet\format\KeyValue',
                ),
        ),
        9 => array(
            'var' => 'data_page_offset',
            'isRequired' => true,
            'type' => TType::I64,
        ),
        10 => array(
            'var' => 'index_page_offset',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        11 => array(
            'var' => 'dictionary_page_offset',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        12 => array(
            'var' => 'statistics',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\hongkai\parquet\format\Statistics',
        ),
        13 => array(
            'var' => 'encoding_stats',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\hongkai\parquet\format\PageEncodingStats',
                ),
        ),
        14 => array(
            'var' => 'bloom_filter_offset',
            'isRequired' => false,
            'type' => TType::I64,
        ),
    );

    /**
     * Type of this column *
     * 
     * @var int
     */
    public $type = null;
    /**
     * Set of all encodings used for this column. The purpose is to validate
     * whether we can decode those pages. *
     * 
     * @var int[]
     */
    public $encodings = null;
    /**
     * Path in schema *
     * 
     * @var string[]
     */
    public $path_in_schema = null;
    /**
     * Compression codec *
     * 
     * @var int
     */
    public $codec = null;
    /**
     * Number of values in this column *
     * 
     * @var int
     */
    public $num_values = null;
    /**
     * total byte size of all uncompressed pages in this column chunk (including the headers) *
     * 
     * @var int
     */
    public $total_uncompressed_size = null;
    /**
     * total byte size of all compressed, and potentially encrypted, pages
     * in this column chunk (including the headers) *
     * 
     * @var int
     */
    public $total_compressed_size = null;
    /**
     * Optional key/value metadata *
     * 
     * @var \hongkai\parquet\format\KeyValue[]
     */
    public $key_value_metadata = null;
    /**
     * Byte offset from beginning of file to first data page *
     * 
     * @var int
     */
    public $data_page_offset = null;
    /**
     * Byte offset from beginning of file to root index page *
     * 
     * @var int
     */
    public $index_page_offset = null;
    /**
     * Byte offset from the beginning of file to first (only) dictionary page *
     * 
     * @var int
     */
    public $dictionary_page_offset = null;
    /**
     * optional statistics for this column chunk
     * 
     * @var \hongkai\parquet\format\Statistics
     */
    public $statistics = null;
    /**
     * Set of all encodings used for pages in this column chunk.
     * This information can be used to determine if all data pages are
     * dictionary encoded for example *
     * 
     * @var \hongkai\parquet\format\PageEncodingStats[]
     */
    public $encoding_stats = null;
    /**
     * Byte offset from beginning of file to Bloom filter data. *
     * 
     * @var int
     */
    public $bloom_filter_offset = null;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['type'])) {
                $this->type = $vals['type'];
            }
            if (isset($vals['encodings'])) {
                $this->encodings = $vals['encodings'];
            }
            if (isset($vals['path_in_schema'])) {
                $this->path_in_schema = $vals['path_in_schema'];
            }
            if (isset($vals['codec'])) {
                $this->codec = $vals['codec'];
            }
            if (isset($vals['num_values'])) {
                $this->num_values = $vals['num_values'];
            }
            if (isset($vals['total_uncompressed_size'])) {
                $this->total_uncompressed_size = $vals['total_uncompressed_size'];
            }
            if (isset($vals['total_compressed_size'])) {
                $this->total_compressed_size = $vals['total_compressed_size'];
            }
            if (isset($vals['key_value_metadata'])) {
                $this->key_value_metadata = $vals['key_value_metadata'];
            }
            if (isset($vals['data_page_offset'])) {
                $this->data_page_offset = $vals['data_page_offset'];
            }
            if (isset($vals['index_page_offset'])) {
                $this->index_page_offset = $vals['index_page_offset'];
            }
            if (isset($vals['dictionary_page_offset'])) {
                $this->dictionary_page_offset = $vals['dictionary_page_offset'];
            }
            if (isset($vals['statistics'])) {
                $this->statistics = $vals['statistics'];
            }
            if (isset($vals['encoding_stats'])) {
                $this->encoding_stats = $vals['encoding_stats'];
            }
            if (isset($vals['bloom_filter_offset'])) {
                $this->bloom_filter_offset = $vals['bloom_filter_offset'];
            }
        }
    }

    public function getName()
    {
        return 'ColumnMetaData';
    }


    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == TType::STOP) {
                break;
            }
            switch ($fid) {
                case 1:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->type);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 2:
                    if ($ftype == TType::LST) {
                        $this->encodings = array();
                        $_size0 = 0;
                        $_etype3 = 0;
                        $xfer += $input->readListBegin($_etype3, $_size0);
                        for ($_i4 = 0; $_i4 < $_size0; ++$_i4) {
                            $elem5 = null;
                            $xfer += $input->readI32($elem5);
                            $this->encodings []= $elem5;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 3:
                    if ($ftype == TType::LST) {
                        $this->path_in_schema = array();
                        $_size6 = 0;
                        $_etype9 = 0;
                        $xfer += $input->readListBegin($_etype9, $_size6);
                        for ($_i10 = 0; $_i10 < $_size6; ++$_i10) {
                            $elem11 = null;
                            $xfer += $input->readString($elem11);
                            $this->path_in_schema []= $elem11;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 4:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->codec);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 5:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->num_values);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 6:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->total_uncompressed_size);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 7:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->total_compressed_size);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 8:
                    if ($ftype == TType::LST) {
                        $this->key_value_metadata = array();
                        $_size12 = 0;
                        $_etype15 = 0;
                        $xfer += $input->readListBegin($_etype15, $_size12);
                        for ($_i16 = 0; $_i16 < $_size12; ++$_i16) {
                            $elem17 = null;
                            $elem17 = new \hongkai\parquet\format\KeyValue();
                            $xfer += $elem17->read($input);
                            $this->key_value_metadata []= $elem17;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 9:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->data_page_offset);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 10:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->index_page_offset);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 11:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->dictionary_page_offset);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 12:
                    if ($ftype == TType::STRUCT) {
                        $this->statistics = new \hongkai\parquet\format\Statistics();
                        $xfer += $this->statistics->read($input);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 13:
                    if ($ftype == TType::LST) {
                        $this->encoding_stats = array();
                        $_size18 = 0;
                        $_etype21 = 0;
                        $xfer += $input->readListBegin($_etype21, $_size18);
                        for ($_i22 = 0; $_i22 < $_size18; ++$_i22) {
                            $elem23 = null;
                            $elem23 = new \hongkai\parquet\format\PageEncodingStats();
                            $xfer += $elem23->read($input);
                            $this->encoding_stats []= $elem23;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 14:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->bloom_filter_offset);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                default:
                    $xfer += $input->skip($ftype);
                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('ColumnMetaData');
        if ($this->type !== null) {
            $xfer += $output->writeFieldBegin('type', TType::I32, 1);
            $xfer += $output->writeI32($this->type);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->encodings !== null) {
            if (!is_array($this->encodings)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('encodings', TType::LST, 2);
            $output->writeListBegin(TType::I32, count($this->encodings));
            foreach ($this->encodings as $iter24) {
                $xfer += $output->writeI32($iter24);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->path_in_schema !== null) {
            if (!is_array($this->path_in_schema)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('path_in_schema', TType::LST, 3);
            $output->writeListBegin(TType::STRING, count($this->path_in_schema));
            foreach ($this->path_in_schema as $iter25) {
                $xfer += $output->writeString($iter25);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->codec !== null) {
            $xfer += $output->writeFieldBegin('codec', TType::I32, 4);
            $xfer += $output->writeI32($this->codec);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->num_values !== null) {
            $xfer += $output->writeFieldBegin('num_values', TType::I64, 5);
            $xfer += $output->writeI64($this->num_values);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->total_uncompressed_size !== null) {
            $xfer += $output->writeFieldBegin('total_uncompressed_size', TType::I64, 6);
            $xfer += $output->writeI64($this->total_uncompressed_size);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->total_compressed_size !== null) {
            $xfer += $output->writeFieldBegin('total_compressed_size', TType::I64, 7);
            $xfer += $output->writeI64($this->total_compressed_size);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->key_value_metadata !== null) {
            if (!is_array($this->key_value_metadata)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('key_value_metadata', TType::LST, 8);
            $output->writeListBegin(TType::STRUCT, count($this->key_value_metadata));
            foreach ($this->key_value_metadata as $iter26) {
                $xfer += $iter26->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->data_page_offset !== null) {
            $xfer += $output->writeFieldBegin('data_page_offset', TType::I64, 9);
            $xfer += $output->writeI64($this->data_page_offset);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->index_page_offset !== null) {
            $xfer += $output->writeFieldBegin('index_page_offset', TType::I64, 10);
            $xfer += $output->writeI64($this->index_page_offset);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->dictionary_page_offset !== null) {
            $xfer += $output->writeFieldBegin('dictionary_page_offset', TType::I64, 11);
            $xfer += $output->writeI64($this->dictionary_page_offset);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->statistics !== null) {
            if (!is_object($this->statistics)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('statistics', TType::STRUCT, 12);
            $xfer += $this->statistics->write($output);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->encoding_stats !== null) {
            if (!is_array($this->encoding_stats)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('encoding_stats', TType::LST, 13);
            $output->writeListBegin(TType::STRUCT, count($this->encoding_stats));
            foreach ($this->encoding_stats as $iter27) {
                $xfer += $iter27->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->bloom_filter_offset !== null) {
            $xfer += $output->writeFieldBegin('bloom_filter_offset', TType::I64, 14);
            $xfer += $output->writeI64($this->bloom_filter_offset);
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
    }
}
