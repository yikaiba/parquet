<?php
namespace jocoon\parquet\format;

/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

/**
 * Description for ColumnIndex.
 * Each <array-field>[i] refers to the page at OffsetIndex.page_locations[i]
 */
class ColumnIndex
{
    static public $isValidate = false;

    static public $_TSPEC = array(
        1 => array(
            'var' => 'null_pages',
            'isRequired' => true,
            'type' => TType::LST,
            'etype' => TType::BOOL,
            'elem' => array(
                'type' => TType::BOOL,
                ),
        ),
        2 => array(
            'var' => 'min_values',
            'isRequired' => true,
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
                'type' => TType::STRING,
                ),
        ),
        3 => array(
            'var' => 'max_values',
            'isRequired' => true,
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
                'type' => TType::STRING,
                ),
        ),
        4 => array(
            'var' => 'boundary_order',
            'isRequired' => true,
            'type' => TType::I32,
        ),
        5 => array(
            'var' => 'null_counts',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::I64,
            'elem' => array(
                'type' => TType::I64,
                ),
        ),
    );

    /**
     * A list of Boolean values to determine the validity of the corresponding
     * min and max values. If true, a page contains only null values, and writers
     * have to set the corresponding entries in min_values and max_values to
     * byte[0], so that all lists have the same length. If false, the
     * corresponding entries in min_values and max_values must be valid.
     * 
     * @var bool[]
     */
    public $null_pages = null;
    /**
     * Two lists containing lower and upper bounds for the values of each page.
     * These may be the actual minimum and maximum values found on a page, but
     * can also be (more compact) values that do not exist on a page. For
     * example, instead of storing ""Blart Versenwald III", a writer may set
     * min_values[i]="B", max_values[i]="C". Such more compact values must still
     * be valid values within the column's logical type. Readers must make sure
     * that list entries are populated before using them by inspecting null_pages.
     * 
     * @var string[]
     */
    public $min_values = null;
    /**
     * @var string[]
     */
    public $max_values = null;
    /**
     * Stores whether both min_values and max_values are orderd and if so, in
     * which direction. This allows readers to perform binary searches in both
     * lists. Readers cannot assume that max_values[i] <= min_values[i+1], even
     * if the lists are ordered.
     * 
     * @var int
     */
    public $boundary_order = null;
    /**
     * A list containing the number of null values for each page *
     * 
     * @var int[]
     */
    public $null_counts = null;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['null_pages'])) {
                $this->null_pages = $vals['null_pages'];
            }
            if (isset($vals['min_values'])) {
                $this->min_values = $vals['min_values'];
            }
            if (isset($vals['max_values'])) {
                $this->max_values = $vals['max_values'];
            }
            if (isset($vals['boundary_order'])) {
                $this->boundary_order = $vals['boundary_order'];
            }
            if (isset($vals['null_counts'])) {
                $this->null_counts = $vals['null_counts'];
            }
        }
    }

    public function getName()
    {
        return 'ColumnIndex';
    }


    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == TType::STOP) {
                break;
            }
            switch ($fid) {
                case 1:
                    if ($ftype == TType::LST) {
                        $this->null_pages = array();
                        $_size56 = 0;
                        $_etype59 = 0;
                        $xfer += $input->readListBegin($_etype59, $_size56);
                        for ($_i60 = 0; $_i60 < $_size56; ++$_i60) {
                            $elem61 = null;
                            $xfer += $input->readBool($elem61);
                            $this->null_pages []= $elem61;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 2:
                    if ($ftype == TType::LST) {
                        $this->min_values = array();
                        $_size62 = 0;
                        $_etype65 = 0;
                        $xfer += $input->readListBegin($_etype65, $_size62);
                        for ($_i66 = 0; $_i66 < $_size62; ++$_i66) {
                            $elem67 = null;
                            $xfer += $input->readString($elem67);
                            $this->min_values []= $elem67;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 3:
                    if ($ftype == TType::LST) {
                        $this->max_values = array();
                        $_size68 = 0;
                        $_etype71 = 0;
                        $xfer += $input->readListBegin($_etype71, $_size68);
                        for ($_i72 = 0; $_i72 < $_size68; ++$_i72) {
                            $elem73 = null;
                            $xfer += $input->readString($elem73);
                            $this->max_values []= $elem73;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 4:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->boundary_order);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 5:
                    if ($ftype == TType::LST) {
                        $this->null_counts = array();
                        $_size74 = 0;
                        $_etype77 = 0;
                        $xfer += $input->readListBegin($_etype77, $_size74);
                        for ($_i78 = 0; $_i78 < $_size74; ++$_i78) {
                            $elem79 = null;
                            $xfer += $input->readI64($elem79);
                            $this->null_counts []= $elem79;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                default:
                    $xfer += $input->skip($ftype);
                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('ColumnIndex');
        if ($this->null_pages !== null) {
            if (!is_array($this->null_pages)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('null_pages', TType::LST, 1);
            $output->writeListBegin(TType::BOOL, count($this->null_pages));
            foreach ($this->null_pages as $iter80) {
                $xfer += $output->writeBool($iter80);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->min_values !== null) {
            if (!is_array($this->min_values)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('min_values', TType::LST, 2);
            $output->writeListBegin(TType::STRING, count($this->min_values));
            foreach ($this->min_values as $iter81) {
                $xfer += $output->writeString($iter81);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->max_values !== null) {
            if (!is_array($this->max_values)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('max_values', TType::LST, 3);
            $output->writeListBegin(TType::STRING, count($this->max_values));
            foreach ($this->max_values as $iter82) {
                $xfer += $output->writeString($iter82);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->boundary_order !== null) {
            $xfer += $output->writeFieldBegin('boundary_order', TType::I32, 4);
            $xfer += $output->writeI32($this->boundary_order);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->null_counts !== null) {
            if (!is_array($this->null_counts)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('null_counts', TType::LST, 5);
            $output->writeListBegin(TType::I64, count($this->null_counts));
            foreach ($this->null_counts as $iter83) {
                $xfer += $output->writeI64($iter83);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
    }
}
